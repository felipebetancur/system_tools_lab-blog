---
lang: 'es'
title: "Aprendiendo eBPF para observabilidad, optimizaci√≥n y seguridad."
description: "Tutoriales eBPF"
pubDate: 2025-11-13
heroImage:
  url: '../../../../assets/hero_articulo_eBPF.png'
  alt: 'Image Placeholder pour Article'
tags: ['eBPF', 'Linux', 'Observabilidad', 'Seguridad', 'Optimizaci√≥n', 'BCC', 'Python']
difficulty: 'beginner'
isDraft: false
featured: true
relatedPosts: []
---

import InfoAlert from '@/features/blog/components/InfoAlert.astro';
import { Image } from 'astro:assets';
import opensnoop_output from '@/assets/opensnoop_output.png';
import hello_ebpf_output from '@/assets/holamundo.png';
import bcc_tools from '@/assets/bcc_tracing_tools_2019.png';
import openfiles_output from '@/assets/openfiles_output.png';

# Contenido
  - [üß† ¬øQu√© es eBPF?](#que-es-ebpf)
  - [‚öôÔ∏è ¬øC√≥mo funciona eBPF?](#como-funciona-ebpf)
  - [üßÆ ¬øPara qu√© se utiliza eBPF?](#para-que-se-utiliza-ebpf)
  - [üöÄ ¬øC√≥mo empezar con eBPF?](#como-empezar-con-ebpf)
  - [üßë‚Äçüíª Escribiendo programas eBPF sencillos con BCC](#escribiendo-programas-ebpf-sencillos-con-bcc)
  - [‚ú® Conclusi√≥n](#conclusion)
  - [üìö Bibliograf√≠a y recursos recomendados](#bibliografia-y-recursos-recomendados)

<h2 id="que-es-ebpf">üß† ¬øQu√© es eBPF?</h2>
eBPF (Extended Berkeley Packet Filter) es una tecnolog√≠a avanzada de Linux que permite la ejecuci√≥n segura de programas en el espacio del kernel sin necesidad de modificar el c√≥digo o cargar m√≥dulos; brindando una forma eficiente y flexible de monitorear, analizar y modificar el comportamiento del sistema operativo en tiempo real. eBPF se ha convertido en una herramienta esencial para la observabilidad, seguridad y optimizaci√≥n del rendimiento en sistemas Linux, aunque tambi√©n es compatible con otras plataformas como Windows a trav√©s de proyectos como <a href="https://github.com/microsoft/ebpf-for-windows" target="_blank">eBPF for Windows</a> y para sistemas embebidos con proyectos como <a href="https://github.com/SzymonKubica/micro-bpf" target="_blank">micro-BPF</a>; aqu√≠ nos centraremos en su uso y funcionamiento en Linux.

<h2 id="como-funciona-ebpf">‚öôÔ∏è ¬øC√≥mo funciona eBPF?</h2>
√âsta tecnolog√≠a permite a los desarrolladores escribir programas en un lenguaje de bajo nivel similar a C. Estos programas se compilan y se convierten a un *bytecode* eBPF que es verificado por el kernel de Linux para garantizar que sea seguro antes de ser cargado y ejecutado en el espacio del kernel. Los programas eBPF pueden adjuntarse a varios puntos de entrada en el kernel, como llamadas al sistema, eventos de red, todos los puntos donde se puede recoger informaci√≥n con *perf*, rastreo de funciones, y m√°s; lo que permite una gran flexibilidad en su uso.


<h2 id="para-que-se-utiliza-ebpf">üßÆ ¬øPara qu√© se utiliza eBPF?</h2>
Se utiliza para una variedad de prop√≥sitos, incluyendo:
- **Monitoreo**: permite la recolecci√≥n de m√©tricas y eventos del sistema en tiempo real.
- **Seguridad**: facilita la implementaci√≥n de pol√≠ticas de seguridad y la detecci√≥n de intrusiones.
- **Optimizaci√≥n del rendimiento**: ayuda a identificar cuellos de botella y mejorar la eficiencia del sistema.
- **Redes**: mejora la gesti√≥n del tr√°fico de red y la implementaci√≥n de *firewalls*.

Existen muchos proyectos y herramientas que aprovechan y facilitan el uso de eBPF, algunos son:
- <a href="https://cilium.io/" target="_blank">Cilium</a>: una plataforma de redes y seguridad para contenedores que utiliza eBPF para proporcionar visibilidad y control de red.
- <a href="https://github.com/iovisor/bcc" target="_blank">BCC (BPF Compiler Collection)</a>: un conjunto de herramientas y bibliotecas para crear programas eBPF de manera sencilla.
- <a href="https://github.com/iovisor/bpftrace" target="_blank">bpftrace</a>: una herramienta de trazado de alto nivel que facilita la escritura de scripts eBPF para monitoreo y depuraci√≥n.
- <a href="https://github.com/libbpf/libbpf" target="_blank">libbpf</a>: una biblioteca que proporciona una API para interactuar con eBPF desde aplicaciones de usuario. 

<h2 id="como-empezar-con-ebpf">üöÄ ¬øC√≥mo empezar con eBPF?</h2>
En √©ste art√≠culo, usaremos comandos *one-liners* de eBPF para obtener informaci√≥n b√°sica del sistema y escribiremos un programa simple usando la biblioteca BCC en Python. Aseg√∫rate de tener un entorno Linux con soporte para eBPF (kernel 4.4 o superior) y las herramientas necesarias instaladas.
Para empezar instalaremos BCC y las dem√°s herramientas necesarias en una distribuci√≥n basada en Debian/Ubuntu:

```bash
sudo apt-get update
sudo apt-get install bpfcc-tools linux-headers-$(uname -r) libbpfcc-dev python3-bpfcc
``` 
Las herramientas de BCC incluyen varios scripts √∫tiles que podemos usar directamente desde la l√≠nea de comandos. Por ejemplo, para monitorear los archivos abiertos en el sistema, con informaci√≥n sobre el proceso que los abri√≥ y el nombre del archivo, podemos usar el siguiente comando: 
```bash
sudo /usr/sbin/opensnoop-bpfcc
```
Mientras el comando est√° en ejecuci√≥n, abre otro terminal y ejecuta el comando "ls" o abre archivos para ver c√≥mo se registran en tiempo real. Para detener la ejecuci√≥n y mirar la salida, presiona **Ctrl + C** en el primer terminal.
<figure class="my-6">
  <Image
    src={opensnoop_output}
    alt="Salida del comando opensnoop-bpfcc mostrando procesos como code, ls y los archivos que est√°n abriendo."
    width={900}
    height={600}
    class="rounded-lg"
  />
  <figcaption class="mt-2 text-sm text-center text-muted-foreground italic">
    Salida del comando opensnoop-bpfcc mostrando procesos como code,ls y los archivos que est√°n abriendo.
  </figcaption>
</figure>
Este comando nos proporciona una visi√≥n en tiempo real de los archivos que se est√°n abriendo en el sistema, en el caso del ejemplo, vemos procesos como *code* y *ls* y los archivos que est√°n abriendo; √©sta informaci√≥n es √∫til para monitorear la actividad del sistema y detectar comportamientos inusuales. En el repositorio de <a href="https://github.com/iovisor/bcc" target="_blank">BCC</a>, encontrar√°s scripts y *one-liners* de eBPF que puedes explorar para diferentes prop√≥sitos, como monitorear el uso de CPU, la actividad de red, entre otros.
<figure class="my-6">
  <Image
    src={bcc_tools}
    alt="Herramientas de trazado de BCC 2019."
    width={900}
    height={600}
    class="rounded-lg"
  />
  <figcaption class="mt-2 text-sm text-center text-muted-foreground italic">
    Diagrama de herramientas de trazado disponibles en BCC.
  </figcaption>
</figure>
<h2 id="escribiendo-programas-ebpf-sencillos-con-bcc">üßë‚Äçüíª Escribiendo programas eBPF sencillos con BCC</h2>
Ahora, vamos a escribir un programa eBPF simple que imprima: "Hola, mundo" cada que se crea un nuevo proceso usando la llamada al sistema *sys_clone*. 
Crea un archivo llamado **hello_ebpf.py** y agrega el siguiente c√≥digo:

```python
#!/usr/bin/python
#
# This is a Hello World example that formats output as fields.

from bcc import BPF
from bcc.utils import printb

# define BPF program
prog = """
int hello(void *ctx) {
    bpf_trace_printk("Hola, mundo!\\n");
    return 0;
}
"""

# load BPF program
b = BPF(text=prog)
b.attach_kprobe(event=b.get_syscall_fnname("clone"), fn_name="hello")

# header
print("%-18s %-16s %-6s %s" % ("TIME(s)", "COMM", "PID", "MESSAGE"))

# format output
while 1:
    try:
        (task, pid, cpu, flags, ts, msg) = b.trace_fields()
    except ValueError:
        continue
    except KeyboardInterrupt:
        exit()
    printb(b"%-18.9f %-16s %-6d %s" % (ts, task, pid, msg))
``` 
Guarda el archivo y ejecuta el script con permisos de superusuario:

```bash
sudo python3 hello_ebpf.py
```
Ahora, cada vez que se cree un nuevo proceso en el sistema, ver√°s el mensaje "Hola, mundo!" en la salida de la terminal, junto con informaci√≥n sobre el proceso que lo gener√≥. Puedes probar esto abriendo nuevas terminales y ejecutando comandos como "ls", "cat", etc. Para detener la ejecuci√≥n, presiona **Ctrl + C**.
<figure class="my-6">
  <Image
    src={hello_ebpf_output}
    alt="Hola, mundo en tiempo real con eBPF."
    width={900}
    height={600}
    class="rounded-lg"
  />
  <figcaption class="mt-2 text-sm text-center text-muted-foreground italic">
    Salida del programa hello_ebpf.py mostrando "Hola, mundo!" cada que se crea un nuevo proceso.
  </figcaption>
</figure>
El script utiliza BCC para definir un programa eBPF que se adjunta a la llamada al sistema *clone*, que es responsable de crear nuevos procesos. Cada vez que se llama a *clone*, el programa eBPF imprime el mensaje en el b√∫fer de trazas del kernel, que luego es le√≠do, formateado y presentado en la terminal por el script de Python.

‚ö†Ô∏è La funci√≥n bpf_trace_printk() es simple pero tiene limitaciones (m√°ximo 3 argumentos) y solo debe usarse para pruebas. Para herramientas de producci√≥n, se usa BPF Maps o perf buffers para una transferencia de datos eficiente entre el kernel y el espacio de usuario.

Volviendo a nuestro primer *one-liner* **opensnoop-bpfcc**, escribamos una versi√≥n simplificada en Python usando BCC. Crea un archivo llamado **open_files.py** y agrega el siguiente c√≥digo:

```python
#!/usr/bin/python

from bcc import BPF

prog = """
struct data_t {
    u32 pid;
    char comm[16];
    char filename[256];
};

BPF_PERF_OUTPUT(events);

TRACEPOINT_PROBE(syscalls, sys_enter_openat) {
    struct data_t data = {};

    // Obtener PID y comando
    u64 pid_tgid = bpf_get_current_pid_tgid();
    data.pid = pid_tgid >> 32;
    bpf_get_current_comm(&data.comm, sizeof(data.comm));

    // Leer filename desde los argumentos del tracepoint
    // args->filename contiene el puntero
    bpf_probe_read_user_str(&data.filename, sizeof(data.filename), (void *)args->filename);

    events.perf_submit(args, &data, sizeof(data));

    return 0;
}
"""

b = BPF(text=prog)

print("%-16s %-6s %s" % ("PROCESO", "PID", "ARCHIVO"))
print("=" * 80)

def print_event(cpu, data, size):
    event = b["events"].event(data)

    comm = event.comm.decode('utf-8', 'replace')
    filename = event.filename.decode('utf-8', 'replace').rstrip('\x00')

    # Solo imprimir si hay un nombre de archivo v√°lido
    if filename and len(filename) > 0:
        print("%-16s %-6d %s" % (comm, event.pid, filename))

b["events"].open_perf_buffer(print_event)

print("Capturando... Presiona Ctrl+C para salir\n")

try:
    while 1:
        b.perf_buffer_poll()
except KeyboardInterrupt:
    print("\nFinalizando...")
``` 
Guarda el archivo y ejec√∫talo con permisos de superusuario:
```bash
sudo python3 open_files.py
```
Ahora, cada vez que un proceso abra un archivo, ver√°s el nombre del proceso, su PID y el nombre del archivo en la terminal. Puedes verificar abriendo otra terminal y ejecutando comandos que abran archivos, como "cat", "ls", etc.

<figure class="my-6">
  <Image
    src={openfiles_output}
    alt="Salida del script open_files.py mostrando procesos y archivos abiertos."
    width={900}
    height={600}
    class="rounded-lg"
  />
  <figcaption class="mt-2 text-sm text-center text-muted-foreground italic">
    Salida del script open_files.py capturando archivos abiertos con informaci√≥n sobre el proceso que los abre.
  </figcaption>
</figure>

En √©ste script usamos de nuevo la biblioteca BCC para cargar y ejecutar un programa eBPF que rastrea las llamadas al sistema de apertura de archivos mediante el *tracepoint* *"syscalls:sys_enter_openat"*.

Explicaci√≥n breve del c√≥digo:
- Se define la estructura *(data_t)* para guardar el PID del proceso, el nombre del comando y el nombre del archivo abierto.

- Se usa un *tracepoint probe* sobre *sys_enter_openat* que se activa cada vez que un proceso llama a la funci√≥n openat para abrir un archivo.

- En el *probe*, obtenemos el PID y el nombre del comando del proceso actual.

- Luego, usamos *bpf_probe_read_user_str* para leer el nombre del archivo abierto.

- Enviamos la informaci√≥n a espacio usuario a trav√©s de un buffer de eventos *perf (events.perf_submit)*.

- En Python, se imprime una cabecera y se define una funci√≥n para recibir eventos desde el buffer perf y mostrar en consola el proceso, PID y archivo abierto.

- Se ejecuta un loop que escucha eventos en tiempo real hasta que se interrumpe con Ctrl+C.


<h2 id="conclusion">‚ú® Conclusi√≥n</h2>
eBPF es una tecnolog√≠a poderosa que ofrece numerosas ventajas para la observabilidad, seguridad y optimizaci√≥n del rendimiento en sistemas Linux. En √©ste art√≠culo exploramos herramientas *one-liners* de eBPF disponibles en BCC, y escribimos programas simples en Python usando la biblioteca BCC para monitorear la apertura de archivos y la creaci√≥n de procesos. Aunque BCC ofrece una manera r√°pida y sencilla de trabajar con eBPF ya que nos da una capa de abstracci√≥n adicional que nos ayuda con el proceso de compilaci√≥n y ejecuci√≥n de programas, existen otras bibliotecas m√°s avanzadas para trabajar con eBPF. En el pr√≥ximo art√≠culo exploraremos un poco m√°s sobre los puntos de entrada o *hooks* disponibles en eBPF, adem√°s de c√≥mo usar la biblioteca libbpf y bpftool para escribir programas eBPF en lenguaje C, compilarlos y cargarlos en el kernel de Linux.

<h2 id="bibliografia-y-recursos-recomendados">üìö Bibliograf√≠a y recursos recomendados</h2>
- <a href="https://ebpf.io/" target="_blank">eBPF Documentation</a>
- <a href="https://cilium.io/" target="_blank">Cilium</a>
- <a href="https://github.com/iovisor/bcc" target="_blank">BCC GitHub Repository</a>
- <a href="https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md" target="_blank">bcc Python Developer Tutorial</a>
- <a href="https://www.brendangregg.com/ebpf.html" target="_blank">Linux Extended BPF (eBPF) Tracing Tools</a>
- <a href="https://github.com/libbpf/libbpf" target="_blank">libbpf GitHub Repository</a>
- <a href="https://github.com/libbpf/bpftool" target="_blank">bpftool GitHub Repository</a>
- <a href="https://github.com/iovisor/bpftrace" target="_blank">bpftrace GitHub Repository</a>